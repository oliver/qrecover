<!DOCTYPE html>
<html>
    <meta charset="utf-8"/>

    <script type="text/javascript">
    var code_size = 25;
    var pixel_size = 20;
    var pixel_data = new Array(code_size);
    for (var i = 0; i < pixel_data.length; i++) {
        pixel_data[i] = new Array(code_size);
        pixel_data[i].fill(false);
    }

    var areas = new Array();

    var canvas, ctx;


    function add_area (id, x, y, w, h, color_values, check_function) {
        areas[id] = {
            "id":id,
            "x":x,
            "y":y,
            "w":w,
            "h":h,
            "color":color_values,
            "check_function":check_function
        };
    }

    function get_pixels_as_bools (px, py, w, h, pixel_data_to_read = pixel_data) {
        var result_array = new Array();
        for (var y = py; y < py+h; y++) {
            for (var x = px; x < px+w; x++) {
                result_array.push(pixel_data_to_read[x][y] ? true : false);
            }
        }
        return result_array;
    }

    function get_pixels_as_string (px, py, w, h) {
        var result_string = "";
        for (var bool_value of get_pixels_as_bools(px, py, w, h)) {
            result_string += (bool_value ? "x" : ".");
        }
        return result_string;
    }

    function expect_pixels (pos_and_size, expected_values) {
        var pixel_string = get_pixels_as_string(pos_and_size[0], pos_and_size[1], pos_and_size[2], pos_and_size[3]);

        if (expected_values.length != pos_and_size[2] * pos_and_size[3]) {
            throw {"desc":"internal error: bad expected size"};
        }
        for (var i = 0; i < pixel_string.length; i++) {
            if (pixel_string[i] != expected_values[i]) {
                throw {
                    "x": (i % pos_and_size[2] ) + 1,
                    "y": (Math.floor(i / pos_and_size[2])) + 1
                };
            }
        }
    }

    function init() {
        add_all_areas();

        var top_div = document.getElementById("area_details");
        for (var id in areas) {
            var area = areas[id];
            area.div = document.createElement("div");
            top_div.appendChild(area.div);
        }

        canvas = document.getElementById('can');
        canvas.width = code_size*pixel_size;
        canvas.height = code_size*pixel_size;
        ctx = canvas.getContext("2d");

        draw_code();
        canvas.addEventListener("mousedown", function (e) {
            var [pix_x, pix_y] = event_to_pixel(e);
            toggle_pixel(pix_x, pix_y);
        }, false);

        canvas.addEventListener("mousemove", function (e) {
            var [pix_x, pix_y] = event_to_pixel(e);
            if (pix_x < code_size && pix_y < code_size) {
                document.getElementById("mouse_pos").innerHTML = "(" + (pix_x+0) + " / " + (pix_y+0) + ")";
            }
        }, false);
    }

    function add_all_areas () {
        // three position markers:
        add_area("pos_ul", 0, 0, 7, 7, [0, 255, 0], function (area) {
            expect_pixels([area.x+0, area.y+0, 7, 7],
                "xxxxxxx" +
                "x.....x" +
                "x.xxx.x" +
                "x.xxx.x" +
                "x.xxx.x" +
                "x.....x" +
                "xxxxxxx"
            );
            return "valid";
        });
        add_area("pos_ur", code_size-7, 0, 7, 7, [0, 255, 0], areas["pos_ul"].check_function);
        add_area("pos_bl", 0, code_size-7, 7, 7, [0, 255, 0], areas["pos_ul"].check_function);

        // one orientation marker (bottom right):
        add_area("orient", 16, 16, 5, 5, [0, 255, 0], function (area) {
            expect_pixels([area.x+0, area.y+0, 5, 5],
                "xxxxx" +
                "x...x" +
                "x.x.x" +
                "x...x" +
                "xxxxx"
            );
            return "valid";
        });

        // spacers around all position markers:
        add_area("spacing_ul_1", 0, 7, 8, 1, [192, 255, 128], function (area) {
            expect_pixels([area.x, area.y, area.w, area.h], "........");
            return "valid";
        });
        add_area("spacing_ul_2", 7, 0, 1, 7, [192, 255, 128], function (area) {
            expect_pixels([area.x, area.y, area.w, area.h], ".......");
            return "valid";
        });
        add_area("spacing_ur_1", code_size-8, 7, 8, 1, [192, 255, 128], areas["spacing_ul_1"].check_function);
        add_area("spacing_ur_2", code_size-8, 0, 1, 7, [192, 255, 128], areas["spacing_ul_2"].check_function);
        add_area("spacing_bl_1", 0, code_size-8, 8, 1, [192, 255, 128], areas["spacing_ul_1"].check_function);
        add_area("spacing_bl_2", 7, code_size-7, 1, 7, [192, 255, 128], areas["spacing_ul_2"].check_function);

        // two timing strips:
        add_area("timing_top", 8, 6, 9, 1, [0, 0, 255], function (area) {
            expect_pixels([area.x, area.y, area.w, area.h], "x.x.x.x.x");
            return "valid";
        });
        add_area("timing_left", 6, 8, 1, 9, [0, 0, 255], areas["timing_top"].check_function);

        // error correction level (redundantly):
        const error_correction_levels = {
            0: "H / High",
            1: "Q / Quartile",
            2: "M / Medium",
            3: "L / Low"
        };
        add_area("format_ec_1", 0, 8, 2, 1, [255, 128, 0], function (area) {
            const [bit0, bit1] = get_pixels_as_bools(area.x, area.y, area.w, area.h);
            const ec_level = ((bit0 << 1) | bit1) ^ 0b10;
            return "EC Level: " + ec_level + " (" + error_correction_levels[ec_level] + ")";
        });
        add_area("format_ec_2", 8, code_size-2, 1, 2, [255, 128, 0], function (area) {
            const [bit1, bit0] = get_pixels_as_bools(area.x, area.y, area.w, area.h);
            const ec_level = ((bit0 << 1) | bit1) ^ 0b10;
            return "EC Level: " + ec_level + " (" + error_correction_levels[ec_level] + ")";
        });

        // mask pattern (redundantly):
        add_area("format_mask_1", 2, 8, 3, 1, [128, 255, 0], function (area) {
            const [bit0, bit1, bit2] = get_pixels_as_bools(area.x, area.y, area.w, area.h);
            const mask_value = ((bit0 << 2) | (bit1 << 1) | bit2) ^ 0b101;
            return {
                "desc": "Mask: " + mask_value + " (0b" + mask_value.toString(2) + ")",
                "mask_value": mask_value
            };
        });
        add_area("format_mask_2", 8, code_size-5, 1, 3, [128, 255, 0], function (area) {
            const [bit2, bit1, bit0] = get_pixels_as_bools(area.x, area.y, area.w, area.h);
            const mask_value = ((bit0 << 2) | (bit1 << 1) | bit2) ^ 0b101;
            return {
                "desc": "Mask: " + mask_value + " (0b" + mask_value.toString(2) + ")",
                "mask_value": mask_value
            };
        });

        // encoding:
        add_area("encoding", code_size-2, code_size-2, 2, 2, [255, 0, 0], function (area) {
            const [bit3, bit2, bit1, bit0] = get_pixels_as_bools(area.x, area.y, area.w, area.h, get_masked_pixels());
            const encoding_value = (bit0 << 3) | (bit1 << 2) | (bit2 << 1) | bit3;
            return "Encoding: " + encoding_value + " (0b" + encoding_value.toString(2) + ")";
        });
    }

    function get_masked_pixels () {
        const mask_types = {
            0: function (i,j) { return (i+j) % 2 == 0; },
            1: function (i,j) { return i % 2 == 0; },
            2: function (i,j) { return j % 3 == 0; },
            3: function (i,j) { return (i + j) % 3 == 0; },
            4: function (i,j) { return (i/2 + j/3) % 2 == 0; },
            5: function (i,j) { return (i*j)%2 + (i*j)%3 == 0; },
            6: function (i,j) { return ((i*j)%3 + i*j) % 2 == 0; },
            7: function (i,j) { return ((i*j) % 3 +i+j) % 2 == 0; }
        };

        var mask_value = areas["format_mask_1"].check_function(areas["format_mask_1"])["mask_value"];
        const mask_bit_function = mask_types[mask_value];

        var masked_pixel_data = new Array(code_size);
        for (var x = 0; x < code_size; x++) {
            masked_pixel_data[x] = new Array(code_size);
            for (var y = 0; y < code_size; y++) {
                var mask_bit_set = mask_bit_function(y, x);
                masked_pixel_data[x][y] = pixel_data[x][y] ^ mask_bit_set;
            }
        }
        return masked_pixel_data;
    }

    function draw_grid () {
        ctx.strokeStyle = "rgba(0,0,0, 0.5)";
        ctx.lineWidth = 1;
        for (i = 0; i < code_size; i++) {
            ctx.beginPath();
            ctx.moveTo(i * pixel_size, 0);
            ctx.lineTo(i * pixel_size, code_size*pixel_size);
            ctx.stroke();
            ctx.closePath();

            ctx.beginPath();
            ctx.moveTo(0, i * pixel_size);
            ctx.lineTo(code_size * pixel_size, i*pixel_size);
            ctx.stroke();
            ctx.closePath();
        }
    }

    function event_to_pixel (e) {
        var pix_x = Math.floor((e.clientX - canvas.offsetLeft) / pixel_size);
        var pix_y = Math.floor((e.clientY - canvas.offsetTop) / pixel_size);
        return [pix_x, pix_y];
    }

    function toggle_pixel (px, py) {
        var set_pixel = !(pixel_data[px][py]);
        pixel_data[px][py] = set_pixel;
        draw_code();
    }

    function draw_rect (px, py, w, h) {
        ctx.fillRect(px*pixel_size, py*pixel_size, w*pixel_size, h*pixel_size);
    }

    function draw_code () {
        ctx.fillStyle = "white";
        ctx.fillRect(0, 0, code_size*pixel_size, code_size*pixel_size);

        for (var x = 0; x < code_size; x++) {
            for (var y = 0; y < code_size; y++) {
                draw_pixel(x, y, pixel_data[x][y]);
            }
        }

        for (id in areas) {
            area = areas[id];
            ctx.fillStyle = "rgba(" + area.color[0] + ", " + area.color[1] + ", " + area.color[2] + ", 0.5)";
            draw_rect(area.x, area.y, area.w, area.h);

            area.div.innerHTML = "<b>" + id + ":</b><br>";
            try {
                var result_obj = area.check_function(area);
                if (typeof(result_obj) == "object") {
                    area.div.innerHTML += result_obj["desc"];
                } else {
                    area.div.innerHTML += result_obj;
                }
            } catch (ex) {
                if (ex.hasOwnProperty("x")) {
                    area.div.innerHTML += "<span style='color: red;'>Invalid Pixel at (" + ex.x + "/" + ex.y + ")</span>";
                } else if (ex.desc) {
                    area.div.innerHTML += "<span style='color: red;'>Error</span> (" + ex.desc + ")";
                } else {
                    area.div.innerHTML += "<span style='color: red;'>Invalid Pixels</span><br>(" + ex + ")";
                }
            }
        }
        draw_grid();
    }

    function draw_pixel (px, py, set_pixel) {
        ctx.beginPath();
        ctx.fillStyle = set_pixel ? "black" : "white";
        ctx.fillRect(px*pixel_size, py*pixel_size, pixel_size, pixel_size);
        ctx.closePath();
    }

    function load_from_file (img_input_field) {
        const [file] = img_input_field.files;
        if (file) {
            var img_obj = new Image();
            img_obj.src = URL.createObjectURL(file);
            img_obj.onload = function () {
                var img_canvas = document.createElement("canvas");
                img_canvas.width = img_obj.width;
                img_canvas.height = img_obj.height;
                img_canvas.getContext("2d").drawImage(img_obj, 0, 0, img_obj.width, img_obj.height);
                var image_pixel_data = img_canvas.getContext("2d").getImageData(0, 0, img_obj.width, img_obj.height).data;

                for (var x = 0; x < Math.min(img_obj.width, code_size); x++) {
                    for (var y = 0; y < Math.min(img_obj.height, code_size); y++) {
                        const red_value = image_pixel_data[(y*img_obj.width + x) * 4];
                        pixel_data[x][y] = (red_value < 128) ? true : false;
                    }
                }
                draw_code();
            }
        }
    }
    </script>

    <body onload="init()">
        <form>
            <input accept="image/*" type="file" id="imgInp" />
            <input type="button" value="Load Selected File" onclick="load_from_file(this.form.imgInp)">
        </form>
        <form>
            <input type="button" value="Export Pixels">
        </form>
        <br>
        <canvas id="can" style="border:2px solid;"></canvas>

        <div id="area_details" style="float:right">
            Areas:
        </div>
        <br>
        <span id="mouse_pos"></span>
    </body>
    </html>
