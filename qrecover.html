<!DOCTYPE html>
<html>
    <meta charset="utf-8"/>
    <title>QRecover</title>

    <script src="error_correction.js"></script>
    <script src="main_canvas.js"></script>
    <script src="preview_image.js"></script>

    <script type="text/javascript">
    var code_size = 25;
    var pixel_size = 20;
    var pixel_data = new Array(code_size);
    for (var i = 0; i < pixel_data.length; i++) {
        pixel_data[i] = new Array(code_size);
        pixel_data[i].fill(false);
    }

    var static_areas = new Map();
    var dynamic_areas  = new Map();
    var highlighted_area = null;
    var highlighted_differences = null;

    var static_area_grid = null;


    // character table for Alphanumeric encoding
    var alphanumeric_table = new Map([
        [36, " "],
        [37, "$"],
        [38, "%"],
        [39, "*"],
        [40, "+"],
        [41, "-"],
        [42, "."],
        [43, "/"],
        [44, ":"],
        [45, "\uFFFD"],
    ]);
    for (var i = 0; i <= 9; i++) {
        alphanumeric_table.set(i, "" + i); // numbers
    }
    for (var i = 10; i <= 35; i++) {
        alphanumeric_table.set(i, String.fromCharCode(i - 10 + 65)); // uppercase letters
    }

    function add_area (id, region_list, color_values, check_function, target_map = static_areas) {
        target_map.set(id, {
            "id":id,
            "regions":[],
            "color":color_values,
            "outline:":null,
            "dom_elements": new Map(),
            "check_function":check_function
        });

        var num_pixels = 0;
        for (region of region_list) {
            target_map.get(id).regions.push({
                "x": region[0], "y": region[1], "w": region[2], "h": region[3]
            });
            num_pixels += region[2] * region[3];
        }
        target_map.get(id).num_pixels = num_pixels;

        target_map.get(id).outline = calc_outline(target_map.get(id).regions);
        return target_map.get(id);
    }

    function get_all_areas () {
        return new Map([...static_areas, ...dynamic_areas]);
    }

    // @param region An object with x,y,w,h attributes
    function get_pixels_as_bools (region, pixel_data_to_read = pixel_data) {
        var result_array = new Array();
        for (var y = region.y; y < region.y+region.h; y++) {
            for (var x = region.x; x < region.x+region.w; x++) {
                result_array.push(pixel_data_to_read[x][y] ? true : false);
            }
        }
        return result_array;
    }

    // @param regions An array of region objects, each of which can be passed to get_pixels_as_bools()
    function get_pixels_from_regions_as_bools (regions, pixel_data_to_read = pixel_data) {
        var result_array = new Array();
        for (var region of regions) {
            result_array = result_array.concat(get_pixels_as_bools(region, pixel_data_to_read));
        }
        return result_array;
    }

    function expect_pixels (regions, expected_values) {
        const bool_array = get_pixels_from_regions_as_bools(regions);
        if (expected_values.length != bool_array.length) {
            throw {"desc":"internal error: bad expected size"};
        }
        for (var i = 0; i < bool_array.length; i++) {
            const expected_value = (expected_values[i] == "x" ? true : false);
            if (bool_array[i] != expected_value) {
                const [x, y] = pixel_at_bit_offset(regions, i);
                throw {
                    "x": x,
                    "y": y
                };

            }
        }
    }

    function save_state () {
        sessionStorage.setItem("pixel_data", JSON.stringify(pixel_data));
    }

    function restore_state () {
        try {
            if (sessionStorage.getItem("pixel_data")) {
                pixel_data = JSON.parse(sessionStorage.getItem("pixel_data"));
                return true;
            }
        } catch (ex) {
            console.log("error restoring saved pixel data (" + ex + ")");
        }
    }

    function highlight_area (area) {
        if (highlighted_area) {
            for (const [element_location_id, element] of highlighted_area.dom_elements) {
                element.style.outline = "";
            }
        }

        highlighted_area = area;

        if (highlighted_area) {
            for (const [element_location_id, element] of highlighted_area.dom_elements) {
                element.style.outline = "3px solid red";
            }
        }
        draw_code();
    }

    function init() {
        update_load_button();

        add_static_areas();
        static_area_grid = calculate_static_area_grid();

        init_main_canvas(document.getElementById("can"), document.getElementById("mouse_pos"));
        init_preview_image(document.getElementById("preview_canvas"), document.getElementById("preview_image"));

        if (!restore_state()) {
            load_from_img_object(document.getElementById('img_example_code'));
        }
        decode();
        draw_code();
    }

    const error_correction_levels = {
        2: "H / High",
        3: "Q / Quartile",
        0: "M / Medium",
        1: "L / Low"
    };

    function add_static_areas () {
        // three position markers:
        add_area("pos_ul", [[0, 0, 7, 7]], [0, 255, 0], function (area) {
            expect_pixels(area.regions,
                "xxxxxxx" +
                "x.....x" +
                "x.xxx.x" +
                "x.xxx.x" +
                "x.xxx.x" +
                "x.....x" +
                "xxxxxxx"
            );
            return {"valid": true};
        });
        add_area("pos_ur", [[code_size-7, 0, 7, 7]], [0, 255, 0], static_areas.get("pos_ul").check_function);
        add_area("pos_bl", [[0, code_size-7, 7, 7]], [0, 255, 0], static_areas.get("pos_ul").check_function);

        // one orientation marker (bottom right):
        add_area("orient", [[16, 16, 5, 5]], [0, 255, 0], function (area) {
            expect_pixels(area.regions,
                "xxxxx" +
                "x...x" +
                "x.x.x" +
                "x...x" +
                "xxxxx"
            );
            return {"valid": true};
        });

        // spacers around all position markers:
        add_area("spacing_ul_1", [[0, 7, 8, 1], [7, 0, 1, 7]], [192, 255, 128], function (area) {
            expect_pixels(area.regions, "........" + ".......");
            return {"valid": true};
        });
        add_area("spacing_ur_1", [[code_size-8, 0, 1, 7], [code_size-8, 7, 8, 1]], [192, 255, 128], static_areas.get("spacing_ul_1").check_function);
        add_area("spacing_bl_1", [[0, code_size-8, 8, 1], [7, code_size-7, 1, 7]], [192, 255, 128], static_areas.get("spacing_ul_1").check_function);

        // two timing strips:
        add_area("timing_top", [[8, 6, 9, 1]], [0, 0, 255], function (area) {
            expect_pixels(area.regions, "x.x.x.x.x");
            return {"valid": true};
        });
        add_area("timing_left", [[6, 8, 1, 9]], [0, 0, 255], static_areas.get("timing_top").check_function);

        // error correction level (redundantly):
        add_area("format_ec_1", [[0, 8, 2, 1]], [255, 128, 0], function (area) {
            const [bit0, bit1] = get_pixels_as_bools(area.regions[0]);
            const ec_level = bits_to_int([bit0, bit1]) ^ 0b10;
            return {"value": ec_level, "num_bits": 2, "desc": "EC Level: " + ec_level + " (" + error_correction_levels[ec_level] + ")"};
        });
        add_area("format_ec_2", [[8, code_size-1, 1, 1], [8, code_size-2, 1, 1]], [255, 128, 0], function (area) {
            const bits = get_pixels_from_regions_as_bools(area.regions);
            const ec_level = bits_to_int(bits) ^ 0b10;

            const ec_1_value = static_areas.get("format_ec_1").check_function(static_areas.get("format_ec_1")).value;
            var valid = true;
            var desc_text = "EC Level: " + ec_level + " (" + error_correction_levels[ec_level] + ")";
            if (ec_1_value != ec_level) {
                valid = false;
                desc_text += "; error: value doesn't match \"format_ec_1\" value";
            }
            // TODO: also perform this validity check in format_ec_1 itself.
            // But to avoid infinite recursion, I guess the best solution would be to split part of the check_function() into a new value_function(),
            // which can just return the value and num_bits, but does not perform own validity checks.

            return {"value": ec_level, "num_bits": 2, "desc": desc_text, "valid": valid};
        });

        // mask pattern (redundantly):
        add_area("format_mask_1", [[2, 8, 3, 1]], [128, 255, 0], function (area) {
            const [bit0, bit1, bit2] = get_pixels_as_bools(area.regions[0]);
            const mask_value = bits_to_int([bit0, bit1, bit2]) ^ 0b101;
            return {
                "desc": "Mask: " + mask_value + " (0b" + mask_value.toString(2) + ")",
                "num_bits": 3,
                "value": mask_value
            };
        });
        add_area("format_mask_2", [[8, code_size-3, 1, 1], [8, code_size-4, 1, 1], [8, code_size-5, 1, 1]], [128, 255, 0], function (area) {
            const bits = get_pixels_from_regions_as_bools(area.regions);
            const mask_value = bits_to_int(bits) ^ 0b101;

            const mask_1_value = static_areas.get("format_mask_1").check_function(static_areas.get("format_mask_1")).value;
            var valid = true;
            var desc_text = "Mask: " + mask_value + " (0b" + mask_value.toString(2) + ")";
            if (mask_1_value != mask_value) {
                valid = false;
                desc_text += "; error: value doesn't match \"format_mask_1\" value";
            }
            // TODO: also perform this validity check in format_mask_1 itself.

            return {
                "desc": desc_text,
                "valid": valid,
                "num_bits": 3,
                "value": mask_value
            };
        });

        function do_complete_format_ec_check (area, format_ec_area_id, format_mask_area_id) {
            const value = bits_to_int(get_pixels_from_regions_as_bools(area.regions, get_masked_pixels()));

            var result = {
                "num_bits": area.num_pixels,
                "value": value
            };

            const ec_value = static_areas.get(format_ec_area_id).check_function(static_areas.get(format_ec_area_id)).value;
            const mask_value = static_areas.get(format_mask_area_id).check_function(static_areas.get(format_mask_area_id)).value;
            const full_ec_bits = (ec_value << 13) | (mask_value << 10) | value;

            const check_result = check_format_ec(full_ec_bits);

            if (check_result != 0) {
                result["valid"] = false;
                result["desc"] = "checksum does not match content";
            }

            return result;
        }

        // error correction values for format and mask (currently only added so that the data bits are read correctly):
        add_area("format_ec_data_1", [
                [5, 8, 1, 1], [7, 8, 2, 1], [8, 7, 1, 1],
                // list these regions separately, to get correct order of bits:
                [8, 5, 1, 1], [8, 4, 1, 1], [8, 3, 1, 1], [8, 2, 1, 1], [8, 1, 1, 1], [8, 0, 1, 1]
            ], [192, 128, 128], function(area) {
            return do_complete_format_ec_check(area, "format_ec_1", "format_mask_1");
        });

        add_area("format_ec_data_2", [[8, code_size-6, 1, 1], [8, code_size-7, 1, 1], [code_size-8, 8, 8, 1]], [192, 128, 128], function(area) {
            // TODO: also check that format_ec_data_1 has the same value?
            return do_complete_format_ec_check(area, "format_ec_2", "format_mask_2");
        });

        add_area("dark_module", [[8, code_size-8, 1, 1]], [128, 128, 192], function(area) {
            expect_pixels(area.regions, "x");
            return {"valid": true};
        });
    }

    function bits_to_int (bool_array) {
        var int_result = 0;
        for (bool_value of bool_array) {
            int_result <<= 1;
            int_result |= (bool_value ? 1 : 0);
        }
        return int_result;
    }

    function get_full_mask () {
        const mask_types = {
            0: function (i,j) { return (i+j) % 2 == 0; },
            1: function (i,j) { return i % 2 == 0; },
            2: function (i,j) { return j % 3 == 0; },
            3: function (i,j) { return (i + j) % 3 == 0; },
            4: function (i,j) { return (Math.floor(i/2) + Math.floor(j/3)) % 2 == 0; },
            5: function (i,j) { return (i*j)%2 + (i*j)%3 == 0; },
            6: function (i,j) { return ((i*j)%3 + i*j) % 2 == 0; },
            7: function (i,j) { return ((i*j) % 3 +i+j) % 2 == 0; }
        };

        var mask_value = static_areas.get("format_mask_1").check_function(static_areas.get("format_mask_1"))["value"];
        const mask_bit_function = mask_types[mask_value];

        var mask_data = new Array(code_size);
        for (var x = 0; x < code_size; x++) {
            mask_data[x] = new Array(code_size);
            for (var y = 0; y < code_size; y++) {
                // apply mask only for data areas:
                if (!inside_static_areas(x, y)) {
                    mask_data[x][y] = mask_bit_function(y, x);
                }
            }
        }

        function set_pixels (pixel_data, region, bool_array) {
            if (region.w * region.h != bool_array.length) {
                throw "bad bool_array size"
            }

            var i = 0;
            for (var y = region.y; y < region.y+region.h; y++) {
                for (var x = region.x; x < region.x+region.w; x++) {
                    pixel_data[x][y] = bool_array[i];
                    i++;
                }
            }
        }

        function set_pixels_in_regions (pixel_data, regions, bool_array) {
            var i = 0;
            for (var region of regions) {
                for (var y = region.y; y < region.y+region.h; y++) {
                    for (var x = region.x; x < region.x+region.w; x++) {
                        pixel_data[x][y] = bool_array[i];
                        i++;
                    }
                }
            }
            if (i != bool_array.length) {
                throw "bad bool_array size"
            }
        }

        // 10 101 0000010010
        set_pixels(mask_data, static_areas.get("format_ec_1").regions[0], [true, false]);
        set_pixels_in_regions(mask_data, static_areas.get("format_ec_2").regions, [true, false]);

        set_pixels(mask_data, static_areas.get("format_mask_1").regions[0], [true, false, true]);
        set_pixels_in_regions(mask_data, static_areas.get("format_mask_2").regions, [true, false, true]);

        set_pixels_in_regions(mask_data, static_areas.get("format_ec_data_1").regions, [false, false, false, false, false, true, false, false, true, false]);
        set_pixels_in_regions(mask_data, static_areas.get("format_ec_data_2").regions, [false, false, false, false, false, true, false, false, true, false]);

        return mask_data;
    }

    function get_masked_pixels () {
        var mask_data = get_full_mask();
        var masked_pixel_data = new Array(code_size);
        for (var x = 0; x < code_size; x++) {
            masked_pixel_data[x] = new Array(code_size);
            for (var y = 0; y < code_size; y++) {
                masked_pixel_data[x][y] = pixel_data[x][y] ^ mask_data[x][y];
            }
        }
        return masked_pixel_data;
    }

    function pixel_at_bit_offset (regions, offset) {
        for (var region of regions) {
            if (offset >= (region.w * region.h)) {
                offset -= (region.w * region.h);
                continue;
            }

            const x = offset % region.w;
            const y = Math.floor(offset / region.w);
            return [region.x + x, region.y + y];
        }
        throw "offset " + offset + " is too large";
    }

    function toggle_pixel (px, py) {
        var set_pixel = !(pixel_data[px][py]);
        pixel_data[px][py] = set_pixel;
        decode();
        draw_code();
    }


    function update_area_details_list () {
        var table_body = document.getElementById("area_table_body");
        table_body.innerHTML = "";

        for (const [id, area] of get_all_areas().entries()) {
            var new_row = table_body.insertRow();
            area.dom_elements.set("area_table_div", new_row);
            new_row.addEventListener("mouseover", function (e) {
                highlight_area(area);
            });
            new_row.addEventListener("mouseout", function (e) {
                highlight_area(null);
            });

            if (highlighted_area && id == highlighted_area.id) {
                highlighted_area = area;
            }

            var result_obj;
            try {
                result_obj = area.check_function(area);
            } catch (ex) {
                result_obj = {"valid": false, "desc": "Error: " + ex};
                if (ex.hasOwnProperty("x")) {
                    result_obj.desc = "Invalid Pixel at (" + ex.x + "/" + ex.y + ")";
                } else if (ex.desc) {
                    result_obj.desc = "Error</span> (" + ex.desc + ")";
                } else {
                    result_obj.desc = "Invalid Pixels (" + ex + ")";
                }
            }

            function add_cell (obj, func) {
                var cell = new_row.insertCell();
                if (obj !== undefined) {
                    func(cell);
                } else {
                    cell.innerHTML = "&nbsp;";
                }
                return cell;
            }

            add_cell(result_obj["offset"], (cell) => { cell.innerHTML = result_obj["offset"]; }).style.textAlign = "right";
            add_cell(id, (cell) => { cell.innerHTML = id; });

            add_cell(result_obj["value"], (cell) => { cell.innerHTML = result_obj["value"]; }).style.textAlign = "right";
            var num_hex_digits = Math.ceil(result_obj["num_bits"] / 4);
            add_cell(result_obj["value"], (cell) => { cell.innerHTML = "0x" + result_obj["value"].toString(16).padStart(num_hex_digits,"0"); }).style.textAlign = "right";
            var num_bin_digits = result_obj["num_bits"];
            add_cell(result_obj["value"], (cell) => { cell.innerHTML = result_obj["value"].toString(2).padStart(num_bin_digits,"0"); }).style.textAlign = "right";

            add_cell(result_obj["valid"], (cell) => {
                cell.innerHTML = (result_obj["valid"] ? "\u2713" : "\u2718");
                cell.style.textAlign = "center";
                cell.style.color = (result_obj["valid"] ? "green" : "white");
                cell.style.backgroundColor = (result_obj["valid"] ? "" : "red");
            });
            add_cell(result_obj["desc"], (cell) => { cell.innerHTML = result_obj["desc"] });
        }
    }

    function decode () {
        // read data bits (into an array of bools):
        var curr_x = code_size-1;
        var curr_y = code_size-1;
        var end_reached = false;
        var bit_array = new Array();
        var bit_offset_to_pixel_position = new Array();
        do {
            var bit_set = get_pixels_as_bools({"x":curr_x, "y":curr_y, "w":1, "h":1}, get_masked_pixels())[0];
            bit_array.push(bit_set);
            bit_offset_to_pixel_position.push({"x":curr_x, "y":curr_y});
            [curr_x, curr_y, end_reached] = next_data_pixel_pos(curr_x, curr_y);
        } while (!end_reached);

        // decode data bits:
        function read_int (bits, offset, len) {
            var result_int = 0;
            for (var i = 0; i < len; i++) {
                if (offset + i >= bits.length) {
                    throw "offset " + (offset + i) + " is out of bounds";
                }

                result_int <<= 1;
                if (bits[offset+i]) {
                    result_int |= 1;
                }
            }
            return [result_int, offset+len];
        }

        function read_int_and_add_row (bits, offset, len, row_prep_func, row_post_func) {
            var orig_offset = offset;
            var [int_value, read_offset] = read_int(bits, offset, len);

            var regions = [];
            for (var i = 0; i < len; i++) {
                const pos = bit_offset_to_pixel_position[orig_offset+i];
                regions.push([pos.x, pos.y, 1, 1]);
            }

            var read_values = {
                "offset":orig_offset,
                "num_bits": len,
                "value":int_value
            };

            var [name, color] = row_prep_func(read_values);
            const new_area = add_area(name + "_" + orig_offset, regions, color, () => { return read_values; }, dynamic_areas);

            if (row_post_func) {
                row_post_func(read_values, new_area);
            }

            return [int_value, read_offset];
        }

        function calc_num_data_bytes (ec_level) {
            // TODO: this result should also take the size of the QR code into account.
            // Currently this value is only correct for a version-2 code (25x25 pixels)!
            const ec_level_name = error_correction_levels[ec_level][0];
            if (ec_level_name == "L")
                return 34;
            if (ec_level_name == "M")
                return 28;
            if (ec_level_name == "Q")
                return 22;
            if (ec_level_name == "H")
                return 16;
        }

        const ec_level = static_areas.get("format_ec_1").check_function(static_areas.get("format_ec_1")).value;
        const num_data_bits = calc_num_data_bytes(ec_level) * 8;

        const mode_names = new Map([
            [0b0000, "End of Message"],
            [0b0010, "Alphanumeric"],
            [0b0100, "Byte"],
            [0b0111, "ECI"]
        ]);

        dynamic_areas = new Map();
        document.getElementById("error_list").innerHTML = "";
        try {
            var text_characters = [];
            var read_offset = 0;
            while (read_offset < bit_array.length) {
                var [mode, read_offset] = read_int_and_add_row(bit_array, read_offset, 4, (read_result) => {
                    if (mode_names.get(read_result["value"])) {
                        read_result["desc"] = mode_names.get(read_result["value"]);
                        read_result["valid"] = true;
                    } else {
                        read_result["desc"] = "Unsupported mode \"" + read_result["value"] + "\"; decoding aborted";
                        read_result["valid"] = false;
                    }
                    return ["mode", [255, 0, 0]];
                });

                if (mode == 0b0010) {
                    // Alphanumeric encoding
                    var [payload_length, read_offset] = read_int_and_add_row(bit_array, read_offset, 9, (read_result) => {
                        return ["payload_length", [255, 192, 255]];
                    });

                    for (var j = 0; j < Math.floor(payload_length / 2); j++) {
                        var [two_chars, read_offset] = read_int_and_add_row(bit_array, read_offset, 11, (read_result) => {
                            var char2_code = read_result["value"] % 45;
                            var char1_code = (read_result["value"] - char2_code) / 45;
                            read_result["text_payload"] = alphanumeric_table.get(char1_code) + alphanumeric_table.get(char2_code);

                            read_result["desc"] = char1_code + "=" + alphanumeric_table.get(char1_code) + "; " + char2_code + "=" + alphanumeric_table.get(char2_code);
                            return ["two_chars", [255, 255, 192]];
                        }, (read_result, area) => {
                            text_characters.push({"chars": read_result["text_payload"], "area": area });
                        });
                    }
                    if (payload_length % 2 != 0) {
                        // read additional character
                        var [final_char, read_offset] = read_int_and_add_row(bit_array, read_offset, 6, (read_result) => {
                            read_result["text_payload"] = alphanumeric_table.get(read_result["value"]);

                            read_result["desc"] = read_result["value"] + "=" + alphanumeric_table.get(read_result["value"]);
                            return ["final_char", [255, 255, 192]];
                        }, (read_result, area) => {
                            text_characters.push({"chars": read_result["text_payload"], "area": area });
                        });
                    }
                    break;
                } else if (mode == 0b0100) {
                    // Byte encoding
                    var [payload_length, read_offset] = read_int_and_add_row(bit_array, read_offset, 8, (read_result) => {
                        return ["payload_length", [255, 192, 255]];
                    });

                    for (var j = 0; j < payload_length; j++) {
                        var [byte, read_offset] = read_int_and_add_row(bit_array, read_offset, 8, (read_result) => {
                            read_result["desc"] = "ASCII='" + String.fromCharCode(read_result["value"]) + "'";
                            return ["byte", [255, 255, 192]];
                        }, (read_result, area) => {
                            text_characters.push({"chars": String.fromCharCode(read_result["value"]), "area": area });
                        });
                    }
                    break;
                } else if (mode == 0b0111) {
                    // ECI marker
                    var [eci_marker, read_offset] = read_int_and_add_row(bit_array, read_offset, 8, (read_result) => {
                        if (read_result["value"] == 26) {
                            read_result["desc"] = "UTF-8 charset";
                            read_result["valid"] = true;
                        } else {
                            read_result["desc"] = "Unsupported ECI marker \"" + read_result["value"] + "\"";
                            read_result["valid"] = false;
                        }
                        return ["eci_marker", [192, 255, 255]];
                    });
                } else {
                    // Unsupported mode
                    break;
                }
            }

            if (read_offset < num_data_bits - 4) {
                var [mode, read_offset] = read_int_and_add_row(bit_array, read_offset, 4, (read_result) => {
                    if (read_result["value"] == 0) {
                        read_result["desc"] = mode_names.get(read_result["value"]);
                        read_result["valid"] = true;
                    } else {
                        read_result["desc"] = "Unsupported mode \"" + read_result["value"] + "\" (terminator expected)";
                        read_result["valid"] = false;
                    }
                    return ["terminator", [255, 0, 0]];
                });
            }
            if (read_offset % 8 != 0) {
                const num_bits_missing_for_byte = 8 - (read_offset % 8);
                var [mode, read_offset] = read_int_and_add_row(bit_array, read_offset, num_bits_missing_for_byte, (read_result) => {
                    read_result["desc"] = "Padding Bits"
                    if (read_result["value"] == 0) {
                        read_result["valid"] = true;
                    } else {
                        read_result["desc"] += " (invalid values; should be 0)";
                        read_result["valid"] = false;
                    }
                    return ["padding", [255, 255, 192]];
                });
            }
            const valid_padding_values = [236, 17];
            var padding_value_index = 0;
            while (read_offset < num_data_bits) {
                let expected_padding_value = valid_padding_values[padding_value_index];
                padding_value_index++;
                padding_value_index %= 2;
                const pad_length = Math.min(num_data_bits - read_offset, 8);
                var [mode, read_offset] = read_int_and_add_row(bit_array, read_offset, pad_length, (read_result) => {
                    read_result["desc"] = "Padding Byte"
                    if (read_result["value"] == expected_padding_value) {
                        read_result["valid"] = true;
                    } else {
                        read_result["desc"] += " (invalid value; should be " + expected_padding_value + ")";
                        read_result["valid"] = false;
                    }
                    return ["padding", [255, 255, 192]];
                });
            }
        } catch (ex) {
            var list_element = document.createElement("li");
            list_element.appendChild(document.createTextNode("Note: decoding failed (\"" + ex + "\"); decoding was aborted."));
            document.getElementById("error_list").appendChild(list_element);
        }

        var num_text_characters = 0;
        for (const entry of text_characters) {
            num_text_characters += entry.chars.length;
        }
        document.getElementById("text_payload").innerHTML = "Decoded " + bit_array.length + " data bits; found " + num_text_characters + " characters:<br>";

        const pre_element = document.createElement("pre");
        document.getElementById("text_payload").appendChild(pre_element);

        for (let entry of text_characters) {
            const span_element = document.createElement("span");
            var displayed_chars = entry.chars;
            // TODO: also replace any other characters that would result in a zero-width span:
            displayed_chars = displayed_chars.replace(/\n/, "\u23ce\n");
            span_element.appendChild(document.createTextNode(displayed_chars));
            span_element.addEventListener("mouseover", function (e) {
                highlight_area(entry.area);
            });
            span_element.addEventListener("mouseout", function (e) {
                highlight_area(null);
            });
            entry.area.dom_elements.set("text_payload_span", span_element);
            pre_element.appendChild(span_element);
        }

        update_area_details_list();
        perform_global_checks();

        // restore highlight in newly-populated area list:
        highlight_area(highlighted_area);
    }

    function perform_global_checks () {
        const ec_1_value = static_areas.get("format_ec_1").check_function(static_areas.get("format_ec_1")).value;
        const mask_1_value = static_areas.get("format_mask_1").check_function(static_areas.get("format_mask_1")).value;
        const ec_data_1_value = static_areas.get("format_ec_data_1").check_function(static_areas.get("format_ec_data_1")).value;
        const full_ec_1_bits = (ec_1_value << 13) | (mask_1_value << 10) | ec_data_1_value;
        const check_result_1 = check_format_ec(full_ec_1_bits);

        const ec_2_value = static_areas.get("format_ec_2").check_function(static_areas.get("format_ec_2")).value;
        const mask_2_value = static_areas.get("format_mask_2").check_function(static_areas.get("format_mask_2")).value;
        const ec_data_2_value = static_areas.get("format_ec_data_2").check_function(static_areas.get("format_ec_data_2")).value;
        const full_ec_2_bits = (ec_2_value << 13) | (mask_2_value << 10) | ec_data_2_value;
        const check_result_2 = check_format_ec(full_ec_2_bits);

        if (check_result_1 != 0 || check_result_2 != 0) {
            const potential_corrections_1 = get_corrections(full_ec_1_bits);
            const potential_corrections_2 = get_corrections(full_ec_2_bits);

            // create list of best corrections, taking both format info sections into account:
            var combined_corrections = new Array();
            for (var {code, distance} of potential_corrections_1) {
                const matching_element_in_2 = potential_corrections_2.find(element => (element.code == code));
                combined_corrections.push({"code": code, "distance_sum": distance + matching_element_in_2.distance});
            }

            combined_corrections.sort((a,b) => {
                if (a.distance_sum != b.distance_sum) {
                    return a.distance_sum - b.distance_sum;
                } else {
                    return a.code - b.code;
                }
            });

            var new_list_element = document.createElement("li");
            new_list_element.innerHTML = "Format data has invalid checksum. Possible corrections:";
            document.getElementById("error_list").appendChild(new_list_element);
            var new_sub_list = document.createElement("ul");
            new_list_element.appendChild(new_sub_list);

            for (var {code, distance_sum} of combined_corrections) {
                const replacement_code = code;
                let replacements = new Array();

                const all_regions_1 = static_areas.get("format_ec_1").regions.concat(static_areas.get("format_mask_1").regions, static_areas.get("format_ec_data_1").regions);
                const all_regions_2 = static_areas.get("format_ec_2").regions.concat(static_areas.get("format_mask_2").regions, static_areas.get("format_ec_data_2").regions);
                const num_bits = 15;
                const replacement_code_masked = replacement_code ^ 0b101010000010010;
                for (var i = 0; i < num_bits; i++) {
                    const bit = (replacement_code_masked >> (num_bits - i - 1)) & 1;
                    const [x_1, y_1] = pixel_at_bit_offset(all_regions_1, i);
                    replacements.push({"x": x_1, "y": y_1, "value": bit});
                    const [x_2, y_2] = pixel_at_bit_offset(all_regions_2, i);
                    replacements.push({"x": x_2, "y": y_2, "value": bit});
                }

                const ec_value = (replacement_code >> 13) & 0b11;
                const mask_value = (replacement_code >> 10) & 0b111;
                const payload_bits = (replacement_code >> 10) & 0b11111;

                var item_text = "<span style='text-decoration: underline dashed;'>"
                    + payload_bits.toString(2).padStart(5,"0")
                    + " = EC: " + error_correction_levels[ec_value] + ", mask: " + mask_value
                    + " (" + distance_sum + " bit(s) differ) <button>Apply</button></span>";

                var new_sub_item = document.createElement("li");
                new_sub_item.innerHTML = item_text;
                new_sub_list.appendChild(new_sub_item);

                const span = new_sub_item.querySelector("span");
                span.addEventListener("mouseover", function (e) {
                    show_correction(replacements);
                }, false);
                span.addEventListener("mouseout", function (e) {
                    show_correction(null);
                }, false);

                const button = new_sub_item.querySelector("button");
                button.addEventListener("click", function (e) {
                    apply_correction(replacements);
                    show_correction(null);
                }, false);
            }
        }
    }

    function show_correction (replacements) {
        highlighted_differences = replacements;
        draw_code();
    }

    function apply_correction (replacements) {
        for ({x, y, value} of replacements) {
            pixel_data[x][y] = value;
        }
        decode();
        draw_code();
        save_state();
    }

    // Returns the actual next data pixel position (taking static areas into account)
    function next_data_pixel_pos (x, y) {
        // simply skip over positions that are inside an area:
        do {
            [x, y, end_reached] = next_position_in_grid(x, y);
            if (end_reached) {
                return [undefined, undefined, true];
            }
        } while (inside_static_areas(x, y));
        return [x, y, false];
    }

    function inside_area (x, y, area) {
        for (region of area.regions) {
            if (x >= region.x && x < region.x+region.w &&
                y >= region.y && y < region.y+region.h) {
                return true;
            }
        }
        return false;
    }

    function inside_areas (x, y, area_map) {
        for (const [id, area] of area_map.entries()) {
            if (inside_area(x, y, area)) {
                return area;
            }
        }
        return null;
    }

    function inside_static_areas (x, y) {
        // Performance-optimized variant of inside_areas(), which only checks against static_areas
        // and uses a precalculated lookup array.
        return static_area_grid[x][y];
    }

    function calculate_static_area_grid () {
        // create an array that stores for each pixel position the static area it is covered by (or null):
        var grid_data = new Array(code_size);
        for (var x = 0; x < code_size; x++) {
            grid_data[x] = new Array(code_size);
            for (var y = 0; y < code_size; y++) {
                const found_static_area = inside_areas(x, y, static_areas);
                grid_data[x][y] = found_static_area;
            }
        }
        return grid_data;
    }

    // Returns the next data pixel position on the grid (regardless of static areas).
    function next_position_in_grid (x, y) {
        // skip over vertical timing strip
        if (x == 6) {
            return [x-1, y, false];
        }

        // calculate current direction in zig-zag pattern:
        var going_up, going_left;
        if (x >= 7) {
            // right of vertical timing strip
            going_up =   ((x-7) % 4 < 2);
            going_left = ((x-7) % 2 == 1);
        } else {
            // left of vertical timing strip
            going_up =   (x % 4 >= 2);
            going_left = (x % 2 == 1);
        }

        // follow zig-zag pattern:
        var rx = x, ry = y;
        if (going_left) {
            rx--;
        } else {
            rx++;
            if (going_up) {
                ry--;
            } else {
                ry++;
            }
        }

        if (ry < 0) {
            // turn around at top edge
            rx-=2;
            ry++;
        } else if (ry > code_size-1) {
            // turn around at bottom edge
            rx-=2;
            ry--;
        }

        if (rx < 0) {
            // left edge: end of data bits reached
            return [undefined, undefined, true];
        } else {
            return [rx, ry, false];
        }
    }


    // @param regions Array of rectangular regions
    // @returns A list of lines (start_x, start_y, end_x, end_y) that draw the outline of the regions
    function calc_outline (regions) {

        // Maps for single horizontal and vertical lines.
        // Each line is one cell long and goes from the smaller to the larger coordinate.
        // Key: x/y coordinate of start point (as string, to achieve correct comparison).
        // Value: integer (number of lines with that start point).
        var lines_h = new Map();
        var lines_v = new Map();

        function make_key (x, y) {
            // pad integers, to get correct comparisons when sorting lines:
            return "" + x.toString().padStart(4, "0") + "/" + y.toString().padStart(4, "0");
        }

        function parse_key (key) {
            const parts = key.split("/");
            return [parseInt(parts[0]), parseInt(parts[1])];
        }

        function increment_int_map_value (map, key) {
            if (!map.has(key)) {
                map.set(key, 0);
            }
            map.set(key, map.get(key) + 1);
        }

        // add outlines of each region to lines_h and lines_v
        for (var region of regions) {
            for (var x = 0; x < region.w; x++) {
                increment_int_map_value(lines_h, make_key(region.x + x, region.y));
                increment_int_map_value(lines_h, make_key(region.x + x, region.y + region.h));
            }
            for (var y = 0; y < region.h; y++) {
                increment_int_map_value(lines_v, make_key(region.x, region.y + y));
                increment_int_map_value(lines_v, make_key(region.x + region.w, region.y + y));
            }
        }

        // remove (set to 0) any map entries where value > 1 (if the same line exists twice, it indicates adjacent regions)
        for (const [key, num_lines] of lines_h.entries()) {
            if (num_lines < 0 || num_lines > 2) {
                console.log("internal error: unexpected number of overlapping lines");
            }
            if (num_lines == 2) {
                lines_h.set(key, 0);
            }
        }
        for (const [key, num_lines] of lines_v.entries()) {
            if (num_lines < 0 || num_lines > 2) {
                console.log("internal error: unexpected number of overlapping lines");
            }
            if (num_lines == 2) {
                lines_v.set(key, 0);
            }
        }

        lines_h = new Map([...lines_h].sort());
        lines_v = new Map([...lines_v].sort());

        // create lists of final lines from lines_h/v
        var result_lines = new Array();
        for (const [key, num_lines] of lines_h.entries()) {
            if (num_lines > 0) {
                const [x,y] = parse_key(key);
                // merge following line segments together:
                for (var i = 1; /* empty */ ; i++) {
                    const next_key = make_key(x+i, y);
                    if (lines_h.get(next_key) > 0) {
                        lines_h.set(next_key, 0);
                    } else {
                        break;
                    }
                }
                result_lines.push({"x": x, "y": y, "w": i, "h": 0 });
            }
        }
        for (const [key, num_lines] of lines_v.entries()) {
            if (num_lines > 0) {
                const [x,y] = parse_key(key);
                for (var i = 1; /* empty */ ; i++) {
                    const next_key = make_key(x, y+i);
                    if (lines_v.get(next_key) > 0) {
                        lines_v.set(next_key, 0);
                    } else {
                        break;
                    }
                }
                result_lines.push({"x": x, "y": y, "w": 0, "h": i });
            }
        }

        return result_lines;
    }


    function load_from_file (img_input_field) {
        const [file] = img_input_field.files;
        if (file) {
            var img_obj = new Image();
            img_obj.src = URL.createObjectURL(file);
            img_obj.onload = function () {
                load_from_img_object(img_obj);
            }
        }
    }

    function load_from_img_object (img_obj) {
        var img_canvas = document.createElement("canvas");
        img_canvas.width = img_obj.width;
        img_canvas.height = img_obj.height;
        img_canvas.getContext("2d").drawImage(img_obj, 0, 0, img_obj.width, img_obj.height);
        var image_pixel_data = img_canvas.getContext("2d").getImageData(0, 0, img_obj.width, img_obj.height).data;

        for (var x = 0; x < Math.min(img_obj.width, code_size); x++) {
            for (var y = 0; y < Math.min(img_obj.height, code_size); y++) {
                const red_value = image_pixel_data[(y*img_obj.width + x) * 4];
                pixel_data[x][y] = (red_value < 128) ? true : false;
            }
        }
        save_state();
        decode();
        draw_code();
    }

    function update_load_button () {
        document.getElementById("btn_load_image").disabled = (document.getElementById("imgInp").files.length != 1);
    }
    </script>

    <body onload="init()">
        <div style="display: flex; align-items: flex-start; justify-content: space-between;">
        <div>
        <form>
            <input accept="image/*" type="file" id="imgInp" onchange="update_load_button();" />
            <input type="button" id="btn_load_image" value="Load Selected File" onclick="load_from_file(this.form.imgInp)">
        </form>
        Mask Display:
        <input type="radio" name="mask_mode" id="rb_show_masked" onchange="draw_code()" checked><label for="rb_show_masked">Masked</label>
        <input type="radio" name="mask_mode" id="rb_show_unmasked" onchange="draw_code()"><label for="rb_show_unmasked">Unmasked</label>
        <input type="radio" name="mask_mode" id="rb_show_mask" onchange="draw_code()"><label for="rb_show_mask">Mask Itself</label>
        <br>
        Numbers:
        <input type="radio" name="numbering_mode" id="rb_numbers_none" onchange="draw_code()" checked><label for="rb_numbers_none">Hide</label>
        <input type="radio" name="numbering_mode" id="rb_numbers_per_area" onchange="draw_code()"><label for="rb_numbers_per_area">Show for each area</label>
        <input type="radio" name="numbering_mode" id="rb_numbers_data_bits" onchange="draw_code()"><label for="rb_numbers_data_bits">Show for data bits</label>
        <br>
        <input type="checkbox" id="cb_colors_enabled" onchange="draw_code()" checked><label for="cb_colors_enabled">Color areas</label>
        <input type="checkbox" id="cb_outlines_enabled" onchange="draw_code()" checked><label for="cb_outlines_enabled">Show Outlines</label>
        <input type="checkbox" id="cb_grid_enabled" onchange="draw_code()" checked><label for="cb_grid_enabled">Show Grid</label>
        <br>
        <br>
        </div>

            <div>
                <canvas id="preview_canvas" style="display: none"></canvas>
                <img id="preview_image" title="Preview of edited QR code" style="image-rendering: crisp-edges;">
            </div>
        </div>

        <div style="display: flex; align-items: flex-start;">
            <div>
                <canvas id="can"></canvas>
                <br>
                <div id="mouse_pos">&nbsp;</div>
                <br>
                <div id="text_payload"></div>
                <br>
                <ul id="error_list" style="height: 18vh; overflow: scroll"></ul>
            </div>

            <div style="height: 85vh; overflow: scroll">
                <table id="area_table" style="margin-left: 20px">
                    <thead>
                        <tr>
                            <th>Offset</th>
                            <th>Name</th>
                            <th>Value (Dec)</th>
                            <th>Value (Hex)</th>
                            <th>Value (Bin)</th>
                            <th>Valid</th>
                            <th>Description</th></tr>
                    </thead>
                    <tbody id="area_table_body">
                    </tbody>
                </table>
            </div>
        </div>

        <img id="img_example_code" style="display: none" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABkAAAAZCAYAAADE6YVjAAABQUlEQVRIS61W0RKDIAwD/f9Pxmk9y8WYQrmbT7Mgbdoko9Zaf9dT1OPxa09Reyxuj635bz7H4rZLJvGD1UFRwijek2AlXhki8QoZHRbDiPx9moSRcLV/SeIIuH0jZLiWnolqH5KB13H4PYmkFrAGD1HtGbHLzo75G2SezUh9dg+eF6LKGBFqZIjWRIL9VcLLijGi/t0u1sjdR1IzohuJUemtJ5kxJCNGbl+nv89kRd1M0a7syOPcu9jguD0ZMToSqRNlFaxaPMAL2ratHMfRnRhn+dqPLozDVpYdoVPWg+3/WH3UNuW+iASLYs1MFT9Dx3NgTS17l6KxUv2n1TgTRc0oxkbJc3l9pyg88yhOjO/7vpfW2utOkPpnRIozMXz4TAyk83KSjK+x76VvKzjgSNnKhZ/Y+N4V3WI+1T6+pVp7AmL1+/532aUIAAAAAElFTkSuQmCC">
    </body>
    </html>
